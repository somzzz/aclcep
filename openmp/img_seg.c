// Written by Margrit Betie for Image and Video Computing, January 2006
// Compile with 
//   g++ -o hw1-YourLastName  main.c vision.c -lm
// Run with:
//   ./hw1-YourLastName input-image.ppm

#include <math.h>
#include "vision.h"
#include "helpers.c"
#include <queue> 
#include <omp.h>
#include <time.h>

#define BILLION  	1000000000L;

std::queue<struct Task> task_queue;

int main(int argc, char *argv[]) {
	bool use_peakiness = true;
	int num_images = 1;
	int i, j, k, x, y, z; 
	int threshold = 0; // calculate threshold
	int color = 1;
	grayscaleimage image;
	grayscaleimage binary;
	rgbimage colorimage;
	int nr_threads, latura, chuncksize, area_square;
	struct Task process_task;
	struct Task my_task; //root task for discover object
	int id; //id of thread
	int ok; //thread has a task or not
	std::queue<Task> local_tasks_threads; //tasks generated by threads
	struct timespec start, stop, start_read, stop_read, start_processing, stop_processing, start_write, stop_write;
	double elapsed_time, elapsed_time_read, elapsed_time_processing, elapsed_time_write;

	if (argc != 4) {
		printf("Usage: ./img_seg inputimage.pgm nr_threads chunksize \n");
		exit(1);
	}

	srand(time(NULL));
	clock_gettime(CLOCK_REALTIME, &start_read);

	// Grab image, place in memory.
	strcpy(image.name, argv[1]);
	strcpy(binary.name, argv[1]);
	ScanPgm(&image);
	ScanPgm(&binary);

	clock_gettime(CLOCK_REALTIME, &stop_read);
	elapsed_time_read = (stop_read.tv_sec - start_read.tv_sec) 
						+ (double)(stop_read.tv_nsec - start_read.tv_nsec) / (double)BILLION;
	printf("[OPENMP] Read image: %lf \n", elapsed_time_read);

	/* ----- Peakiness Detection for Appropriate Threshold Selection ----- 
	 * -------------------------------------------------------------------
	 */
	clock_gettime(CLOCK_REALTIME, &start_processing);
	if (use_peakiness && num_images == 1) {
		threshold = calculatePeakiness(&image, 0, image.xdim);
	    printf("Threshold: %d\n", threshold);
		// Create a binary output image based on the threshold created.
		for (i = 0; i < binary.ydim; i++) {
			for (j = 0; j < binary.xdim; j++) {
				if ((unsigned int) image.value[i][j] >= threshold) {
					binary.value[i][j] = WHITE;
				}
				else {
					binary.value[i][j] = BLACK;
				}
			}
		}
		normalizeBackground(&binary, 0, binary.xdim);
	}

	/* ----- Connected Component -----
	 * -------------------------------
	 */
	// Initialize by negation.
	for (i = 0; i < binary.ydim; i++) {
		for (j = 0; j < binary.xdim; j++) {
			if (binary.value[i][j] == BLACK) {
				binary.value[i][j] = UNTOUCHED;
			}
		}
	}
	// Create a color copy.
	colorimage.xdim = image.xdim;
	colorimage.ydim = image.ydim;
	colorimage.highestvalue = WHITE;

	GetImagePpm(&colorimage);
	for (i = 0; i < colorimage.ydim; i++) {
		for (j = 0; j < colorimage.xdim; j++) {
			colorimage.r[i][j] = 255;
			colorimage.g[i][j] = 255;
			colorimage.b[i][j] = 255;
		}
	}
	clock_gettime(CLOCK_REALTIME, &stop_processing);
	elapsed_time_processing = (stop_processing.tv_sec - start_processing.tv_sec) 
						+ (double)(stop_processing.tv_nsec - start_processing.tv_nsec) / (double)BILLION;
	printf("[OPENMP] Processing image (Calculate threshold, Normalize background, Get color image): %lf \n", elapsed_time_processing);

	//get number of threads and chunck_size
	nr_threads = atoi(argv[2]);
	chuncksize = atoi(argv[3]);
	//calculate square chunck
	area_square = colorimage.xdim * colorimage.ydim;
	latura = trunc(sqrt(area_square / nr_threads));
	printf("Calculated square chunck is: %d\n", latura);
	int works_threads[nr_threads];
	for (i = 0; i < nr_threads; i++)
	{
		works_threads[i] = false;
	} 
	printf("Image is processed by %d threads and chunck processed by each thread is %d\n", nr_threads, chuncksize);
	//set number of threads and start discover objects
	omp_set_num_threads(nr_threads);
	srand(time(NULL));
	clock_gettime(CLOCK_REALTIME, &start);

	for (i = 0; i < colorimage.ydim; i++) {
			for (j = 0; j < colorimage.xdim; j++) {
				if (binary.value[i][j] == UNTOUCHED) {
					//discover object => generate task having seed in the untouched pixel
					process_task = generateTask(i, j, color, chuncksize, colorimage.xdim, colorimage.ydim);
					task_queue.push(process_task);
					//start the parallel region
					#pragma omp parallel private(x, y, id, ok, my_task, local_tasks_threads) firstprivate(i, j) shared(works_threads, task_queue, binary)
					{
						while(1)
						{
							//get task from queue if exists 
							#pragma omp critical
							{
								if (!task_queue.empty())
								{
									id = omp_get_thread_num();
									works_threads[id] = true;
									my_task = task_queue.front();
									task_queue.pop();
									ok = true;//have task
								} else {
									id = omp_get_thread_num();
									works_threads[id] = false;
									ok = false;//haven't task
								}
							}
							if (ok == true) 
							{
								//has task => local bfs in chunck and create tasks for others
								std::queue<struct Task> chunck_bfs;
								chunck_bfs.push(my_task);

								while (!chunck_bfs.empty()) {
									struct Task local_task = chunck_bfs.front();
									chunck_bfs.pop();
									x = local_task.seed_i; 
									y = local_task.seed_j;

									if (is_in_limits_matrix(x, y, colorimage.ydim, colorimage.xdim) && !is_in_chunck(x, y, &my_task) && (binary.value[x][y] == UNTOUCHED || binary.value[x][y] == TOUCH_IN_PROGRESS))
									{
											//create new task for others threads
											struct Task new_task = generateTask(x, y, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
											#pragma omp critical
											{
												local_tasks_threads.push(new_task);
											}
									}
									if (is_in_chunck(x, y, &my_task) && (binary.value[x][y] == UNTOUCHED || binary.value[x][y] == TOUCH_IN_PROGRESS))
									{
											binary.value[x][y] = BLACK;
											set_color(&colorimage, x, y, my_task.color);
											if (is_in_limits_matrix(x, y - 1, colorimage.ydim, colorimage.xdim) && binary.value[x][y-1] == UNTOUCHED) {
												binary.value[x][y-1] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x, y - 1, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);
											}
											if (is_in_limits_matrix(x, y + 1, colorimage.ydim, colorimage.xdim) && binary.value[x][y+1] == UNTOUCHED) {
												binary.value[x][y+1] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x, y + 1, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);	
											}
											if (is_in_limits_matrix(x - 1, y - 1, colorimage.ydim, colorimage.xdim) && binary.value[x-1][y-1] == UNTOUCHED) {
												binary.value[x-1][y-1] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x - 1, y - 1, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);
											}
											if (is_in_limits_matrix(x - 1, y, colorimage.ydim, colorimage.xdim) && binary.value[x-1][y] == UNTOUCHED) {
												binary.value[x-1][y] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x - 1, y, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);	
											}
											if (is_in_limits_matrix(x - 1, y + 1, colorimage.ydim, colorimage.xdim) && binary.value[x-1][y+1] == UNTOUCHED) {
												binary.value[x-1][y+1] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x - 1, y + 1, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);	
											}
											if (is_in_limits_matrix(x + 1, y - 1, colorimage.ydim, colorimage.xdim) && binary.value[x+1][y-1] == UNTOUCHED) {
												binary.value[x+1][y-1] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x + 1, y - 1, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);	
											}
											if (is_in_limits_matrix(x + 1, y, colorimage.ydim, colorimage.xdim) && binary.value[x+1][y] == UNTOUCHED) {
												binary.value[x+1][y] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x + 1, y, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);	
											}
											if (is_in_limits_matrix(x + 1, y + 1, colorimage.ydim, colorimage.xdim) && binary.value[x+1][y+1] == UNTOUCHED) {
												binary.value[x+1][y+1] = TOUCH_IN_PROGRESS;
												struct Task new_task = generateTask(x + 1, y + 1, my_task.color, my_task.chunck, colorimage.xdim, colorimage.ydim);
												chunck_bfs.push(new_task);	
											}
									}
								}//end while bfs
								while (!local_tasks_threads.empty()) { 
									//put the generated tasks by each thread in the global queue
									#pragma omp critical
									{
										task_queue.push(local_tasks_threads.front());
									}
									local_tasks_threads.pop();
								}
								std::queue<Task> empty;
								std::swap(local_tasks_threads, empty);
							}//end if ok = has task
							works_threads[id] = false; //thread stop working
							//check if there are tasks or some threads are working	
							if (task_queue.empty() && !searchWork(works_threads, nr_threads))
							{
								break;
							}
						}//end while 1
					}//end parallel region					
					color++;
				}//end if
			}//end for j
	}//end for i

	clock_gettime(CLOCK_REALTIME, &stop);
	elapsed_time = ( stop.tv_sec - start.tv_sec )
				+ (double)( stop.tv_nsec - start.tv_nsec ) / (double)BILLION;
	printf("[OPENMP] Image segmentation parallel region: %lf\n", elapsed_time);

	//write the images
	srand(time(NULL));
	clock_gettime(CLOCK_REALTIME, &start_write);	
	strcpy(colorimage.name, "connected.ppm");
	OutputPpm(&colorimage);
	binary.highestvalue = WHITE;
	strcpy(binary.name, "binary.pgm");
	OutputPgm(&binary);
	printf("\n");
	clock_gettime(CLOCK_REALTIME, &stop_write);
	elapsed_time_write = ( stop_write.tv_sec - start_write.tv_sec )
		+ (double)( stop_write.tv_nsec - start_write.tv_nsec )
			/ (double)BILLION;
	printf("[OPENMP] Write image: %lf \n", elapsed_time_write);
	return 0;
}